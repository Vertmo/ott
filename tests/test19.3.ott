% cut-down version of POPLmark language with records and record patterns but without type variables, abstraction and application
% Based on test19.0.ott but with rules tweaked a little so that code_pred in Isabelle works

% This is test19.2.ott with auxilary inductive relations added by hand to provide Isabelle inductive
% predicates that mode check


metavar x , termvar ::=
 {{ isa string }} {{ coq nat }} {{ hol string }}  {{ coq-equality }} {{ lex alphanum }}  
 {{ tex \mathit{[[termvar]]} }} {{ com  term variable  }} 
 {{ isavar ''[[termvar]]'' }} {{ holvar "[[termvar]]" }} {{ texvar \mathrm{[[termvar]]} }} 
 {{ ocamlvar "[[termvar]]" }}

metavar l, label, k ::=
 {{ isa string }} {{ coq nat }} {{ hol string }} {{ lex alphanum }}  {{ tex \mathit{[[label]]} }} 
 {{ com  field label  }}  {{ isavar ''[[label]]'' }} {{ holvar "[[label]]" }}
 {{ ocamlvar "[[label]]" }}

indexvar index, i, j, n, m  ::= {{ isa nat }} {{ coq nat }} {{ hol num }} {{ lex numeral }}
  {{ com indices }}

 grammar



T {{ hol Typ }}, S, U :: 'T_' ::=                                     {{ com type  }}
  | Top                              ::   :: Top                        {{ com maximum type }}   
  | T -> T'                          ::   :: Fun                        {{ com type of functions }}
  | { l1 : T1 , .. , ln : Tn }       ::   :: Rec                        {{ com record }}
  | Rec_list l_list T_list           ::   :: Rec_list
  | ( T )                            :: M :: paren                      {{ ich [[T]] }}
  | < T1 , .. , Tn >                 :: :: Tup 
  | Tup_list T_list     :: :: Tup_list
  
t :: 't_' ::=                                                         {{ com  term  }}
  | x                                ::   :: Var                        {{ com variable }}         
  | \ x : T . t                      ::   :: Lam  (+ bind x in t +)     {{ com abstraction }}      
  | t t'                             ::   :: App                        {{ com application }}      
  | { l1 = t1 ,  .. , ln = tn }      ::   :: Rec                        {{ com record }}
  | Rec_list l_list t_list           ::   :: Rec_list
  | t . l                            ::   :: Proj                       {{ com projection }} 
  | let p = t in t'                  ::   :: Let  (+ bind b(p) in t' +) {{ com pattern binding}}
  | ( t )                            :: M :: paren                      {{ ich [[t]] }} 
  | [ x |-> t ] t'                   :: M :: tsub                       {{ ich ( tsubst_t [[t]] [[x]] [[t']] ) }}
  | s t                              :: M :: tsubs                      {{ ich ( m_t_subst_t [[s]] [[t]] ) }}
  | < t1 , .. , tn >                 ::   :: Tup
  | Tup_list t_list     :: :: Tup_list
  
p :: 'P_' ::=                                                         {{ com  pattern }}
  | x : T                            ::   :: Var  (+ b = x  +)          {{ com variable pattern }}
  | { l1 = p1 , .. , ln = pn }       ::   :: Rec  (+ b = b(p1 .. pn) +) {{ com  record pattern  }}

v :: 'v_' ::=                                                         {{ com  values  }}
  | \ x : T . t                      ::   :: Lam  (+ bind x in t +)     {{ com abstraction }}      
  | { l1 = v1 ,  .. , ln = vn }      ::   :: Rec                        {{ com record }}

G {{ tex \Gamma }}, D {{ tex \Delta }} :: 'G_' ::=                    {{ com type environment }}
  | empty                            ::   :: empty       
  | G , x : T                        ::   :: term
  | G1 , .. , Gn                     :: M :: dots                        {{ ich (flatten_G [[G1..Gn]]) }}  

s {{ tex \sigma }} :: 'S_' ::= {{ com multiple term substitution }} {{ isa (x*t) list }} {{ hol (termvar#t) list }} {{ coq list (termvar*t) }}
  | [ x |-> t ]                    ::   :: singleton {{ ih [ ([[x]],[[t]]) ] }} {{ coq (cons ([[x]],[[t]]) nil) }}
  | s1 , .. , sn                   ::   :: list   {{ isa List.concat [[s1..sn]] }} {{ hol (FLAT [[s1..sn]]) }} {{ coq (List.flat_map (fun x => x) [[s1..sn]]) }}

t_list :: 't_list_' ::= {{ phantom }} {{ isa t list }} 
 | empty :: :: empty       {{ isa Nil }}
% | t1 , .. , tn :: :: list {{  isa ([[ t1 .. tn]]) }}
 | t # t_list :: :: cons   {{ isa ([[t]]#([[t_list]])) }}
 | ( t_list ) :: M :: parens {{ isa ([[t_list]]) }}
 | x_list :: :: x_list {{ isa (List.map (%x. t_var x) [[x_list]]) }}

l_list :: 'l_list_' ::= {{ phantom }} {{ isa l list }}
 | empty :: :: empty       {{ isa Nil }}
% | l1 , .. , tn :: :: list {{  isa ([[ l1 .. ln]]) }}
 | l # l_list :: :: cons   {{ isa ([[l]]#([[l_list]])) }}
 | ( l_list ) :: M :: parens {{ isa ([[l_list]]) }}


x_list :: 'x_list_' ::= {{ phantom }} {{ isa x list }}
 | empty :: :: empty       {{ isa Nil }}
 | x # x_list :: :: cons   {{ isa ([[x]]#([[x_list]])) }}
 | ( x_list ) :: M :: parens {{ isa ([[x_list]]) }}



T_list :: 'T_list_' ::= {{ phantom }} {{ isa T list }}
 | empty :: :: empty    {{ isa Nil }}
% | T1 , .. , Tn :: :: list {{  isa ([[ T1 .. Tn]]) }}
 | T # T_list :: :: cons {{ isa ([[T]]#([[T_list]])) }}
 | ( T_list ) :: M :: parens {{ isa ([[T_list]]) }}


terminals :: terminals_ ::=
  |  \                     ::   :: lambda    {{ tex  \lambda }}
  |  ->                    ::   :: arrow     {{ tex  \rightarrow }}
  |  =>                    ::   :: Arrow     {{ tex  \Rightarrow }}
  | |-                     ::   :: turnstile {{ tex \vdash }}
  | -->                    ::   :: red       {{ tex \longrightarrow }}
  | Forall                 ::   :: forall    {{ tex \forall }}
  | <:                     ::   :: subtype   {{ tex <: }}
  | |->                    ::   :: mapsto    {{ tex \mapsto }}
  | /\                     ::   :: wedge     {{ tex \wedge }}
  | \/                     ::   :: vee       {{ tex \vee }}
  | =                      ::   :: eq        {{ tex \!\! = \!\! }}

formula :: formula_ ::=          
  | judgement              :: :: judgement
% | G = G'                 :: :: Geq     {{ ich [[G]] = [[G']] }}
  | x = x'                 :: :: xeq     {{ ich [[x]] = [[x']]  }}
  | t = t'                 :: :: teq     {{ ich [[t]] = [[t']]  }}	
  | x : T INN G            :: :: lookup  {{ isa Some [[T]] = lookup [[G]] [[x]] }}
  | x_list : T_list INN G            :: :: lookup_list  {{ isa Some [[T_list]] = lookup_list [[G]] [[x_list]] }}	
  | ( formula )            :: :: paren   {{ ich ( [[formula]] ) }}
  | not formula            :: :: not     {{ isa Not( [[formula]] ) }}
                                         {{ coq not( [[formula]] ) }}
                                         {{ hol ~( [[formula]] ) }}
                                         {{ tex \neg [[ formula]] }}
%  | x isin dom ( G )      :: :: xin    {{ isa ? T. ([[x]],T,[[G]]):tin }} 
%                                         {{ tex [[x]] \in [[dom]]([[G]]) }}
  | forall i isin 1 -- m . formula :: :: forall 
                               {{ tex \forall [[i]] \in 1 .. [[m]] . [[formula]] }} 
                               {{ isa ![[i]] . ((1::nat)<=[[i]] & [[i]]<=[[m]]) ==> [[formula]] }} 
                               {{ hol ![[i]] . (1<=[[i]] /\ [[i]]<=[[m]]) ==> [[formula]] }} 
                               {{ coq (forall [[i]], (1<=[[i]] /\ [[i]] <= m) -> [[formula]]) }}

  | exists i isin 1 -- m . formula :: :: exists 
                               {{ tex \exists [[i]] \in 1 .. [[m]]. [[formula]] }}
                               {{ isa ?[[i]]. ((1::nat)<=[[i]] & i<=[[m]]) ==> [[formula]] }} 
                               {{ hol ?[[i]] . (1<=[[i]] /\ [[i]]<=[[m]]) ==> [[formula]] }} 
                               {{ coq exists [[i]], (1<=[[i]] /\ [[i]] <= [[m]]) -> [[formula]] }}

  | formula /\ formula'   :: :: and  {{ isa ([[formula]] & [[formula']]) }}
                                     {{ hol ([[formula]] /\ [[formula']]) }}
                                     {{ coq ([[formula]] /\ [[formula']]) }}

  | l = l'                :: :: leq  {{ ich ([[l]]=[[l']]) }}
 
% would be nice to write the above as  {{ isa ?[[T]]. [[X<:T isin G]] }}

%formulalist :: formulalist_ ::=          
   | formula1 ... formulan   :: :: dots


%subrules
%
%  v <:: t


substitutions
  single   t x :: tsubst    
  multiple t x :: m_t_subst 

freevars
  t x :: fv



embed
{{ isa

lemma list_all_cong[fundef_cong]:
     "xs = ys ==> (!!x. x:set ys ==> P x = Q x) ==> list_all P xs = list_all Q ys"
  unfolding list_all_iff
  by auto



(* This is needed so monotonicity for inductive predicates using list_all get through *)
lemma [mono]:"
         (!! x. f x --> g x) ==> list_all (%b. b) (map f foo_list)-->
                    list_all (%b. b) (map g foo_list) "
		       apply(induct_tac foo_list, auto) done

fun lookup :: "G \<Rightarrow> x \<Rightarrow> T option" where
  "lookup _ _ = None"

fun lookup_list :: "G \<Rightarrow> x list \<Rightarrow> (T list) option" where
  "lookup_list _ _ = None"

 primrec append_G :: "G => G => G"
 where
 "append_G G G_empty = G"
| "append_G G (G_term _ _ _) = G"

primrec flatten_G :: "G list => G"
where
 "flatten_G Nil = G_empty "
| "flatten_G (Cons G Gs) = append_G G (flatten_G Gs)"
 }}
 
   {{ hol
 val _ = Define `
    (append_G [[G]] [[empty]] = [[G]])
 /\ (append_G [[G]] [[G',x:T]] = (let [[G'']] = append_G [[G]] [[G']] in [[G'',x:T]]))`;
 val _ = Define `
    (flatten_G NIL = [[empty]])
 /\ (flatten_G (CONS [[G]] Gs) = append_G [[G]] (flatten_G Gs))`;
 }}
 
 {{ coq 
 Fixpoint append_G (g1 g2 : G) {struct g2} : G :=
   match g2 with
   | G_empty => g1
   | G_term gh v t => G_term (append_G g1 gh) v t
 end.
 Fixpoint flatten_G (gl:list_G) : G :=
   match gl with 
   | Nil_list_G => G_empty
   | Cons_list_G g gs => append_G g (flatten_G gs)
 end.  }}

defns
Jtype :: '' ::=


defn
infer_t_list G t_list T_list :: :: TyL :: TyL_
by

--------------- :: Nil
infer_t_list G (:t_list_empty: empty) empty


G |- t : T
infer_t_list G t_list T_list
------------------------------ :: Cons
infer_t_list G (t # t_list) (T # T_list)


defn
G |- t : T ::  :: Ty :: Ty_  {{ com term $[[t]]$ has type $[[T]]$ }} by 

%G|-t1:T1 .. G|-tn:Tn
infer_t_list G t_list T_list
------------------------------------- :: Rcd
%G|- {l1=t1,..,ln=tn}:{l1:T1,..,ln:Tn}
G|- Rec_list l_list t_list : Rec_list l_list T_list


%G |- x1:T1 .. G |- xn : Tn
infer_t_list G t_list T_list
------------------------------------------- :: Tup
%G |- < t1 , .. , tn > : < T1 , .. , Tn >
G |- Tup_list t_list : Tup_list T_list


% Special case for variables that mimics situation I encountered

x_list : T_list INN G
x_list_t_list  x_list t_list
------------------------------------------- :: Tupx
G |- Tup_list t_list : Tup_list T_list

% Two way conversion 
defn
x_list_t_list x_list t_list :: :: XT :: XT_
by

---------------------------- :: empty
x_list_t_list (:x_list_empty: empty) (:t_list_empty: empty)


x = t
x_list_t_list x_list t_list
----------------------------------------  :: cons
x_list_t_list (x # x_list ) (t # t_list )


embed {{ isa

code_pred   (modes: i ⇒ i ⇒ o  ⇒  bool ) [show_steps,  show_mode_inference,  show_invalid_clauses] Ty .

}}
